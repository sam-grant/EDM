#include "../Blinding/Blinders.hh"
#include "FancyDraw.h"

#include "TTree.h"
#include "TCanvas.h"
#include "TFile.h"
#include "TH1D.h"
#include "TH2D.h"
#include "TProfile.h"
#include "TGraphErrors.h"

// SETUP BLINDING

using namespace blinding;

bool unblind = false; // true; // false;

double R = 3.5; // ppm shift
double boxWidth = 0.25;
double gausWidth = 0.7;

Blinders::fitType ftype = Blinders::kOmega_a;
Blinders getBlinded( ftype, "Blinding string", boxWidth, gausWidth );

// CONSTANTS
double e = 1.6e-19; // J
double aMu = 11659208.9e-10; 
double mMu = 105.6583715; // u
double mMuKg = mMu * 1.79e-30; // kg
double B = 1.451269; // T
double c = 299792458.; // m/s
double cm2m = 100.0; // cm -> m
double hbar = 1.05457e-34;
double pmagic = mMu/std::sqrt(aMu);
double gmagic = std::sqrt( 1.+1./aMu );
double beta   = std::sqrt( 1.-1./(gmagic*gmagic) );
double d0 = 1.9e-19; // BNL edm limit in e.cm
double ppm = 1e-6;
double alpha = 0.13; // asymmetry factor
//double TESTEDM = d0 / 2.; 

double blinded_edm_value(bool unblind) {

  // returns a blinded input edm value. returned dMu will be unphysical. it will be in the range of +- 3*d0 centred around 10*d0

  // How far from the ref value are we
  double omega_diff;
  if(!unblind) { // unblinded verions
    omega_diff = ((getBlinded.paramToFreq(R) / getBlinded.referenceValue()) - 1) / ppm;
  } else if(unblind) {
    Blinders myBlinder( ftype ); // Just to print out the warning
    // I think that you have to reapply the new blinding to the blinded plot to unblind it. 
    //omega_diff = (myBlinder.paramToFreq(R) / myBlinder.referenceValue() - 1) / ppm;
    omega_diff = 0.0;
  }

  double dMu_blind = omega_diff * d0; // this is the blinded dMu in e.cm
  
  return dMu_blind;
  
}

// For sanity check d_mu plot
double blinded_edm_value(std::string tmp) {
  
  //
  // returns a blinded input edm value. returned dMu will be unphysical. it will be in the range of +- 3*d0 centred around 10*d0
  //

  //Blinders myBlinder( ftype );
  Blinders getBlinded( ftype, tmp.c_str(), boxWidth, gausWidth );

  double omega_blind = getBlinded.paramToFreq(R); // this is the blinded omegaA value
  double omega_ref   = getBlinded.referenceValue(); // this is the reference omegaA value
  // How far from the ref value are we
  double omega_diff  =  ((omega_blind / omega_ref) - 1) / ppm; // this is (omega_blind - omega_ref) in units of ppm
  double dMu_blind   = omega_diff * d0; // this is the blinded dMu in e.cm
  
  //if (!testFlag)  {
  return dMu_blind;
  //}
  //else {
  //  return TESTEDM;
  //}

}

double GetDelta(double dMu) {
  double eta = ((4 * mMuKg * c * dMu)/ (hbar * cm2m) );
  double dMu_tmp = (hbar * cm2m * eta) / (4 * mMuKg * c);
  std::cout<<"eta_check:\t"<<eta<<std::endl;
  std::cout<<"dMu_check:\t"<<dMu_tmp<<std::endl;
  double tan_delta = (eta * beta) / (2 * aMu);
  double delta = atan(tan_delta);
  return delta;
}

double OmegaFunc( double *x, double *p )  {
  double time = x[0];//-p[5]; // Time offset
  return p[0] * exp(-time/p[1]) * ( 1 - p[2] * cos(p[3] * time + p[4]));
}

double EDMFunc( double *x, double *p )  {
  double time = x[0];// + p[3]; // time offset
  return (-p[0] * cos(p[1]* time + p[2]));
}

// int main() {
int main(int argc, char *argv[]) {

    //std::string unblindStr = "unblinded"

    if (unblind) {
      std::cout << "\n========= UNBLINDED ==========" << "\n";
    }

    std::string config = "5.4e-18";//30xBNL"; 
    std::string cuts = argv[1];
    std::string qualString = cuts+"Q";
    
    // // Read file
    // std::string config = "30xBNL"; // 1xBNL"
    // std::string qualString = "Q";

    // Read file
    TFile *input = TFile::Open(("../Plots/MC/dMu/"+config+"/dMuSim_"+qualString+".root").c_str());
    std::cout << "\nRead input...\t\t: " << input << std::endl;
    
    // TFile *input = TFile::Open(("../Plots/MC/"+config+"/moduloPlots"+qualString+".root").c_str());
    // std::cout << "\nRead input...\t\t: " << input << std::endl;

    // ================== First, fit N(t) for the phase ================== 

    // Get unmodulated theta_y vs time for N(t) plot  
    TH2D *ThetaY_vs_Time = (TH2D*)input->Get("ThetaY_vs_Time"); 
    DrawTH2(ThetaY_vs_Time,"","../Images/BlindedFits/"+config+"/ThetaY_vs_Time_2D");
    TProfile *ThetaY_vs_Time_Prof = ThetaY_vs_Time->ProfileX();
    // DrawTH1(ThetaY_vs_Time_Prof,"","../Images/BlindedFits/"+std::to_string(config)+"ThetaY_vs_Time_Prof");

    // Make n(t) histogram
    int nbinsx = ThetaY_vs_Time_Prof->GetNbinsX();
    int x1 = ThetaY_vs_Time_Prof->GetXaxis()->GetBinLowEdge(0);
    int x2 = ThetaY_vs_Time_Prof->GetXaxis()->GetBinUpEdge(nbinsx-1);
    TH1D* ThetaY_vs_Time_1D = new TH1D("ThetaY_vs_Time_1D","",nbinsx,x1,x2);

    for (int i_bin(0); i_bin< ThetaY_vs_Time_Prof->GetNbinsX(); i_bin++) {
      double entries =  ThetaY_vs_Time_Prof->GetBinEntries(i_bin);
      //double error = ThetaY_vs_Time_Prof->GetBinError(i_bin);
      ThetaY_vs_Time_1D->SetBinContent(i_bin,entries);
      //ThetaY_vs_Time_1D->SetBinError(i_bin,error);
    }

    // Initial time cuts
    double xmin = 34.844+G2PERIOD/2;//G2PERIOD*7;
    double xmax = 34.844+G2PERIOD*10+G2PERIOD/2;//70;

    ThetaY_vs_Time_1D->GetXaxis()->SetRangeUser(xmin,xmax);

    // Fit the number hist to get a guess at the phase
    TF1* omegaFunc = new TF1("omegaFunc",OmegaFunc,xmin,xmax,5);//,6);
    omegaFunc->SetParNames("N","#gamma#tau","A","#omega","#phi");//,"off");//,"Time offset"); 
    omegaFunc->SetNpx(50000);

    omegaFunc->SetParameter(1,64.4); // Muon lifetime, assists fit
    // Fix omega_a to blinded reference value
    omegaFunc->SetParLimits(2,0.0,0.3);
    omegaFunc->SetParameter(3,getBlinded.referenceValue());
    omegaFunc->FixParameter(3,getBlinded.referenceValue());
    omegaFunc->SetParLimits(4,0,2*M_PI);
    // Fix the time offset to the start time
    omegaFunc->SetParameter(5,xmin);
    //omegaFunc->FixParameter(5,xmin);

    ThetaY_vs_Time_1D->Fit(omegaFunc,"MR");

    //DrawTH1Fit(ThetaY_vs_Time_1D,omegaFunc,";Time [#mus];N(t)","../Images/BlindedFits/"+std::to_string(config)+"ThetaY_vs_Time_1D"); 

    double phi_omega = omegaFunc->GetParameter(4);
    // Shift the phase 90 deg
    double phi_edm = phi_omega + M_PI/2.; 
    // Find a zero crossing 
    double t0 = phi_omega * G2PERIOD / (2*M_PI);
    double zeroCrossing = 8*G2PERIOD - t0;

    ThetaY_vs_Time_1D->GetXaxis()->SetRangeUser(zeroCrossing,zeroCrossing+2*G2PERIOD);

    //DrawTH1Fit(ThetaY_vs_Time_1D,omegaFunc,";Time [#mus];N(t)","../Images/BlindedFits/"+std::to_string(config)+"ThetaY_vs_Time_1D_Check");

    std::cout<<"t0\t"<<t0<<std::endl;
    std::cout<<"zeroCrossing\t"<<zeroCrossing<<std::endl;

    delete ThetaY_vs_Time; delete ThetaY_vs_Time_1D; delete ThetaY_vs_Time_Prof; delete omegaFunc;

    // ================== Second, get blinded A_EDM ================== 

    double dMu_blind = blinded_edm_value(unblind);  //1.6e-19*30;//
    std::cout<<"dMu_blind:\t"<<dMu_blind<<std::endl;
    double delta_blind = GetDelta(dMu_blind);
    double omega_a = getBlinded.referenceValue(); 
    double tan_A_edm = tan(delta_blind) / gmagic;

    double A_edm = alpha*atan(tan_A_edm) * 1e3; // 0.13 is asymmetry factor

    // ================== Third, inject blinded A_EDM into modulo plot ==================

    // Define blinded EDM oscillation
    TF1* edmFunc = new TF1("edmFunc",EDMFunc,zeroCrossing,zeroCrossing+G2PERIOD,3);
    edmFunc->SetParNames("A_{EDM blinded}","#omega_{a BNL}","#phi");//,"offset");
    edmFunc->SetParameters(A_edm,omega_a,phi_edm);//,xmin);
    edmFunc->SetNpx(50000);
    //edmFunc->GetXaxis()->SetRangeUser(zeroCrossing,zeroCrossing+G2PERIOD);

    DrawTF1(edmFunc,"Blind EDM function;Time [#mus];#LT#theta_{y}#GT [mrad]","../Images/MC/dMu/"+config+"/Blinded/BlindEDMFunc"+qualString+"_"+to_string(unblind));

    TH2D *ThetaY_vs_Time_Modulo = (TH2D*)input->Get("ThetaY_vs_Time_Modulo");
    // Do this as a TH1
    TProfile *ThetaY_vs_Time_Modulo_Prof = ThetaY_vs_Time_Modulo->ProfileX(); 

    delete ThetaY_vs_Time_Modulo;

    // Sanity check
    // TH1D *htmp = new TH1D("","",100,0,14);
    // for (int i(0); i<10e3; i++) htmp->Fill(blinded_edm_value(std::to_string(i))*1e19);
    // DrawTH1(htmp,"","../Images/BlindedFits/"+config+"dMu");
  
    int nBins = ThetaY_vs_Time_Modulo_Prof->GetNbinsX();
    int nEntries = ThetaY_vs_Time_Modulo_Prof->GetEntries();

    double x[nBins];
    double ex[nBins];
    double y[nBins];
    double ey[nBins];

    for (int i(0); i<nBins; i++) {

      double time = ThetaY_vs_Time_Modulo_Prof->GetBinCenter(i+1);
      double theta_y = ThetaY_vs_Time_Modulo_Prof->GetBinContent(i+1);
      double theta_y_shift = edmFunc->Eval(time);

      x[i] = time;
      ex[i] = 0;
      y[i] = theta_y + theta_y_shift;
      ey[i] = ThetaY_vs_Time_Modulo_Prof->GetBinError(i+1);

    }

    delete ThetaY_vs_Time_Modulo_Prof; delete edmFunc;

    TGraphErrors *result = new TGraphErrors(nBins,x,y,ex,ey);

    DrawTGraphErrors(result,";t_{g#minus2}^{mod} [#mus];#LT#theta_{y}#GT [mrad]","../Images/MC/dMu/"+config+"/Blinded/Modulo_"+qualString+"_"+to_string(unblind));

    // Fit
    SimpleSinFit(result, 0.15, OMEGA_A * 1e3, 0);

    double accept = 1.8069889;
    double A_edm_tot = result->GetFunction("SimpleSinFunc")->GetParameter(0) * 1.95;//accept;
    
    // Calculate limit for fun, not sure if physical. What's the dilution factor?

    double eta_tot = (2*aMu/beta*gmagic) * tan( (A_edm_tot*1e-3) /alpha);
    double dMu_tot = (hbar * cm2m * eta_tot) / (4 * mMuKg * c); //(hbar * e * cm2m * eta_tot) / (4 * mMu * 1e-6 * c);
    std::cout<<"A_edm_tot:\t"<<A_edm_tot<<std::endl;
    std::cout<<"eta_tot:\t"<<eta_tot<<std::endl;
    std::cout<<"dMu_tot:\t"<<dMu_tot<<std::endl;

    DrawSimpleSinFit(result, ";t_{g#minus2}^{mod} [#mus];#LT#theta_{y}#GT [mrad]", "../Images/MC/dMu/"+config+"/Blinded/ModuloFit_"+qualString+"_"+to_string(unblind), nEntries, unblind);

  return 0;

}