// Perform a very simple fit over time slices

// Sam Grant 
// Jan 2020
// samuel.grant.18@ucl.ac.uk

#include <iostream>

#include "TFile.h"
#include "TMath.h"
#include "TCanvas.h"
#include "TH1D.h"
#include "TH2D.h"
#include "TStyle.h"
#include "TAxis.h"
#include "TProfile.h"
#include "TF1.h"
#include "TDirectory.h"
#include "TObject.h"
#include "TGraph.h"
#include "TLegend.h"
#include "TPaveStats.h"
#include "TPaveText.h"
#include "TVirtualFFT.h"
#include "TGraphErrors.h"

using namespace std;

double RadialCBOFuncSlice(double *x, double *par) {

  // Slice wiggle with constant amplitude, and a normalistation term
  return (par[0]*cos(par[1]*x[0]-par[2]))+par[3];  

}

void RadialCBOFitSlice(TH1D *hist, double startTime, double endTime, int stn) {
  
//  float startTime = startPeriod * T_CBO;
//  float endTime = endPeriod * T_CBO;

  TF1 *func = new TF1("RadialCBOFuncSlice", RadialCBOFuncSlice, startTime, endTime, 4);

  func->SetParameter(0,10);  // Amplitude
  func->SetParameter(1,2); 
// ,TMath::Pi()); 
  // Fix the phase
  if(stn==12) func->SetParameter(2,TMath::Pi());
  else if(stn==18) func->SetParameter(2,TMath::Pi()/2);

  func->SetParName(0,"A"); // [mm]
  func->SetParName(1,"#omega"); // [rad/#mus]
  func->SetParName(2,"#phi"); // [rad]
  func->SetParName(3,"R_{0}"); // [mm]

  func->SetNpx(10000);

  hist->Fit(func,"QMR");
  
  cout << "Chi^2/ndf:\t" << func->GetChisquare() / func->GetNDF() << endl;

  return;

}

double OmegaShiftFunc(double *x, double *par) {

  // Slice wiggle with constant amplitude, and a normalistation term
  return par[0]*(1-TMath::Exp(-x[0]/par[1]));

}

void OmegaShiftFit(auto *gr, double startTime, double endTime) {

  TF1 *func = new TF1("OmegaShiftFunc", OmegaShiftFunc, startTime, endTime, 2);

  func->SetParameter(0,2);  // Amplitude
  func->SetParameter(1,5); 

  func->SetParName(0,"#omega_{0}");
  func->SetParName(1,"#tau");
//  func->SetParName(0,"A"); // [mm]
//  func->SetParName(1,"#omega"); // [rad/#mus]
//  func->SetParName(2,"#phi"); // [rad]
//  func->SetParName(3,"R_{0}"); // [mm]

//  func->SetNpx(10000);

  gr->Fit(func,"MR");
  
  cout << "Chi^2/ndf:\t" << func->GetChisquare() / func->GetNDF() << endl;

  return;

}




// Stolen wholesale from EuropaFitter
TH1D* GetResidual(TH1D* data, TF1* fit, double min, double max) { // , TH1F* pull){

  int nbins = data->GetXaxis()->GetNbins();
  double binWidth = data->GetBinWidth(1);
  double low = data->GetXaxis()->GetBinLowEdge(1);
  double high = low + nbins*binWidth;
  TH1D* residual = new TH1D("residual", "", nbins, low, high);  

  for (int ibin(1); ibin <= nbins; ibin++){
    residual->SetBinContent(ibin, 0.0);
    double time = residual->GetXaxis()->GetBinCenter(ibin);
    if (time > max) break;// residual->SetBinContent(ibin,0);// break;
    else if (time >= min) {
      double cont = data->GetBinContent(ibin);
      double err = data->GetBinError(ibin);
      //double integral = fit->Integral( data->GetBinLowEdge(ibin), data->GetBinLowEdge(ibin) + binWidth );
      double integral = fit->Eval(time);
      residual->SetBinContent(ibin, integral - cont);
      residual->SetBinError(ibin, err);
      // pull->Fill( (integral - cont) / err);
    }
  }
  return residual;
}

// Get FFT of residual 
TH1D* GetFFT(TH1D* hist, double fitStartTime, double fitEndTime) {

  // Grab start/end x-axis of input hist
  // double xlow = hist->GetXaxis()->GetXmin();
  // cout<<xlow<<", "<<start<<endl;
  // double xhi = hist->GetXaxis()->GetXmax();
  // cout<<xhi<<", "<<end<<endl;
                                                      
  TH1 *hm = 0;
  TVirtualFFT::SetTransform(0);
  hm = hist -> FFT(hm, "MAG");


  //Rescale x-axis by dividing by the function domain              
  TAxis *xaxis = hm -> GetXaxis();

  int nBins = hist->GetXaxis()->GetNbins();
  double *ba = new double[nBins+1];
  xaxis -> GetLowEdge(ba);
  double Scale = 1./(hist->GetXaxis()->GetXmax() - hist->GetXaxis()->GetXmin());
  ba[nBins] = ba[nBins-1] + xaxis -> GetBinWidth(nBins);

  for (int i = 0; i < nBins + 1; i++) {
       ba[i] *= Scale;
  }
 
  TH1D* fftResidual = new TH1D(hm -> GetName(), hm -> GetTitle(), nBins, ba);
  for (int i = 0; i <= nBins; i++) {
      fftResidual -> SetBinContent(i, hm -> GetBinContent(i));
      fftResidual -> SetBinError(i, hm -> GetBinError(i));
  }

  //TH1D* fftResidual = (TH1D*)hm->Clone("residualFFT");
  
  fftResidual -> SetStats(0);
  fftResidual -> SetName("residualFFT");
  fftResidual -> Scale(1.0 / fftResidual -> Integral());
 

  //Calculate Nyquist frequency, which is twice the highest frequeny in the signal or half of the sampling rate.                                                                                            
  //...the maximum frequency before sampling errors start              

  //
  // DON'T GET START/END FROM ARGUMENTS!!!!
  //

  double binWidth = hist->GetXaxis()->GetBinWidth(0);//(end - start) / nBins ;
  double sampleRate = 1 / binWidth;
  double nyquistFreq = 0.5 * sampleRate;

  fftResidual->GetXaxis()->SetRangeUser(0, nyquistFreq);

  cout << "binWidth\t" <<binWidth<<" us"<<endl;
  cout << "sampleRate\t" <<sampleRate<<" MHz"<<endl;
  cout << "nyquistFreq\t" <<nyquistFreq<<" MHz"<<endl;

  return fftResidual;
}

// Define a scatter plot
//TGraphErrors* DefineScat(vector<double> x_, vector<double> y_, vector<double> ex_, vector<double> ey_) {
//
//  int n = 0;
//  n = x_.size();
//
//  if(n==0) {
//    cout<<"ERROR IN DEFINING TGraphErrors"<<endl;
//  }
//
//  for(int i = 0; i<n; i++) {
//
//    ey_.push_back(0);
//
//  }
//
//  auto gr = new TGraphErrors(n,x_,y_,ex_,ey_);
//  return gr;
//
//}

void DrawScat(auto gr, string title, string name) {
  
  TCanvas *c = new TCanvas("c","c",800,600);//"","",3000,2000);

  //  gr->SetLineWidth(3);

  TF1 *f1 = gr->GetFunction("OmegaShiftFunc");

    // Book legend, which writes the fit formula
  TLegend *leg = new TLegend(0.55,0.8,0.85,0.85);

  leg->SetBorderSize(0);

  leg->AddEntry(f1,"#omega_{0}(1 #minus e^{-t/#tau})");

  gr->SetMarkerColor(kBlack);
  gr->SetMarkerStyle(20);

  gr->SetTitle(title.c_str());
  
  gr->Draw();
  gPad->Update();
  TPaveStats *statBox = (TPaveStats*) gr->FindObject("stats");
  statBox->SetBorderSize(0);
  statBox->SetX1NDC(0.15);
  statBox->SetX2NDC(0.475);
  statBox->SetY1NDC(0.65);
  statBox->SetY2NDC(0.89);

  gr->GetYaxis()->SetTitleOffset(1.3);
  gr->GetXaxis()->SetTitleOffset(0.9);
  gr->GetXaxis()->CenterTitle(true);
  gr->GetYaxis()->CenterTitle(true);

  //double min = gr->GetFunction("RadialCBOFunc")->GetParName(0) - 0.002;
  //double max = gr->GetFunction("RadialCBOFunc")->GetParName(0) + 0.003;
  //gr->GetYaxis()->SetRangeUser(min, max);

  // gr->GetYaxis()->SetRangeUser(-15, 15);
  // gr->GetXaxis()->SetRangeUser(0, 120);
  //gr->SetTitleSize(.75);
  gr->GetXaxis()->SetTitleSize(.05);
  gr->GetYaxis()->SetTitleSize(.05);

  c->SetLeftMargin(0.13);

  // Dump fit into the top directory of a ROOT file
//  gr->SetDirectory(output);

  gr->Draw("AP");
  leg->Draw("SAME");
//  statBox->Draw

  // Save an images
  c->SaveAs((name+".C").c_str());
  c->SaveAs((name+".pdf").c_str());

  delete c;




}
// Drawing function
void FancyDrawFit(TH1D *hist, string title, string name, TFile *out, bool drawStatBox) {

  TF1 *f1 = hist->GetFunction("RadialCBOFuncSlice");


  // Book legend, which writes the fit formula
  TLegend *leg = new TLegend(0.525,0.75,0.85,0.85);


  leg->SetBorderSize(0);

  leg->AddEntry(f1,"A cos(#omegat #minus #phi) #plus R_{0}");

  TCanvas *c = new TCanvas("c","c",800,600);//"","",3000,2000);
  
  gStyle->SetStatFormat("6.3g");

  hist->Draw();
  gPad->Update();

  gStyle->SetOptStat(0);
  gStyle->SetOptFit(111);
  gStyle->SetOptStat(10);

  //  hist->SetStats(0);
  TPaveStats *statBox = (TPaveStats*) hist->FindObject("stats");

  //statBox->SetBorderSize();
  //  statBox->SetNcolumns(2);
  statBox->SetBorderSize(0);

  statBox->SetX1NDC(0.15);
  statBox->SetX2NDC(0.475);
  statBox->SetY1NDC(0.65);
  statBox->SetY2NDC(0.89);

  //  hist->SetLineWidth(3);
  hist->SetLineColor(kBlack);
  hist->SetTitle(title.c_str());

  hist->GetYaxis()->SetTitleOffset(1.3);
  hist->GetXaxis()->SetTitleOffset(0.9);
  hist->GetXaxis()->CenterTitle(true);
  hist->GetYaxis()->CenterTitle(true);

  //double min = hist->GetFunction("RadialCBOFunc")->GetParName(0) - 0.002;
  //double max = hist->GetFunction("RadialCBOFunc")->GetParName(0) + 0.003;
  //hist->GetYaxis()->SetRangeUser(min, max);

  hist->GetYaxis()->SetRangeUser(-5, 20);
  // hist->GetXaxis()->SetRangeUser(0, 100);
  hist->SetTitleSize(.75);
  hist->GetXaxis()->SetTitleSize(.05);
  hist->GetYaxis()->SetTitleSize(.05);

  c->SetLeftMargin(0.13);

  if(!drawStatBox) hist->SetStats(0);

  hist->Draw();
  leg->Draw("SAME");

  // Dump fit into the top directory of a ROOT file
  hist->SetDirectory(gDirectory);

  // Save an images
  c->SaveAs((name+".C").c_str());
  c->SaveAs((name+".pdf").c_str());

  delete c;

}

// Drawing function
void FancyDraw(TH1 *hist, string title, string name, TFile *out, bool errors, bool twoD) {

  
  TCanvas *c = new TCanvas("c","c",800,600);//"","",3000,2000);

  //  hist->SetLineWidth(3);
  hist->SetStats(0);
  hist->SetLineColor(kBlack);
  hist->SetTitle(title.c_str());

  hist->GetYaxis()->SetTitleOffset(1.3);
  hist->GetXaxis()->SetTitleOffset(0.9);
  hist->GetXaxis()->CenterTitle(true);
  hist->GetYaxis()->CenterTitle(true);

  //double min = hist->GetFunction("RadialCBOFunc")->GetParName(0) - 0.002;
  //double max = hist->GetFunction("RadialCBOFunc")->GetParName(0) + 0.003;
  //hist->GetYaxis()->SetRangeUser(min, max);

  // hist->GetYaxis()->SetRangeUser(-15, 15);
  // hist->GetXaxis()->SetRangeUser(0, 120);
  hist->SetTitleSize(.75);
  hist->GetXaxis()->SetTitleSize(.05);
  hist->GetYaxis()->SetTitleSize(.05);

  c->SetLeftMargin(0.13);

  if(!twoD) {
    if(!errors) hist->Draw("hist");
    else hist->Draw(); 
  } else if (twoD) {
    gStyle->SetPalette(55);
    hist->Draw("COLZ");

  } 
  // Dump fit into the top directory of a ROOT file
  hist->SetDirectory(gDirectory);

  // Save an images
  c->SaveAs((name+".C").c_str());
  c->SaveAs((name+".pdf").c_str());

  delete c;

}

// Slice fit
int main() {

  // CBO time period
  double T_CBO = 2.69; // us
  double start = 2*T_CBO;
  // double end = 82*T_CBO; 
  double end = 50*T_CBO; 

  //string inputName = "../plots/RadialCBOMerged_run2.root";// RadialCBO_5100A.root";
  string inputName = "../plots/run2C/plots_run2C.root";// RadialCBO_5100A.root";
  string outputName = "../plots/run2C/4par.root";

  TFile *input = TFile::Open(inputName.c_str());
  TFile *output = new TFile(outputName.c_str() , "RECREATE");

  cout << "Reading: " << inputName << " " << input << endl;

  // string histName = "RadialCBO/AnalysisPlots/RadialDecayVertex_vs_DecayTime";
  
  //
  // NEED TO SORT OUT ROOT DIRECTORIES!!!
  //

  for(int stn = 12; stn<19; stn = stn + 6) { 

    string dir = "S"+to_string(stn);

    output->cd();
    output->mkdir(dir.c_str());
    output->cd(dir.c_str());

    string histName = "S"+to_string(stn)+"_RadialDecayVertex_vs_DecayTime";
    
    TH2D *hist = (TH2D*)input->Get(histName.c_str());
    TH1D *prof = hist->ProfileX();
    
    // TIME SLICES

    vector<TH1D*> fits_;
    // vector<TH1D*> res_;
    // vector<TH1D*> fft_; 

    vector<double> chiSquareNDF_; 
    vector<double> omega_;
    vector<double> omegaErrors_; 
    vector<double> phi_; 
    vector<double> time_; 
    vector<double> ex_;

    // 5 time slices, two periods, iterate by ten periods
    for(int i_period = 2; i_period < 130; i_period++) {
    
      TH1D *i_prof = (TH1D*)prof->Clone("i_prof");
      cout<<"period "<<i_period<<endl;
     
      double i_start = (i_period) * T_CBO;
      double i_end = (i_period+2) * T_CBO;

      RadialCBOFitSlice(i_prof, i_start, i_end, stn);

      i_prof->GetXaxis()->SetRangeUser(i_start, i_end);

      fits_.push_back(i_prof);

      // Grab the function
      TF1 *i_func = i_prof->GetFunction("RadialCBOFuncSlice");

      // Store some parameters for plotting
      if(i_func->GetParameter(1)<1.0) continue;
      chiSquareNDF_.push_back(i_func->GetChisquare() / i_func->GetNDF());
      omega_.push_back(i_func->GetParameter(1));  
      omegaErrors_.push_back(i_func->GetParError(1));        
      phi_.push_back(i_func->GetParameter(2));   
      time_.push_back(i_end-i_start/2);  
      ex_.push_back(0);     

    }
    
     
    cout<<"Number of fits\t"<<fits_.size()<<endl;

    for(int i_fit = 0; i_fit<fits_.size(); i_fit++) {
    //prof->GetXaxis()->SetRangeUser(start, end);
    //fits_.push_back(prof);
      FancyDrawFit(fits_.at(i_fit),"Station "+to_string(stn)+";Decay time [#mus];Radial decay position mean [mm]","../images/run2C/4par/slices/S"+to_string(stn)+"_sliceFit_"+to_string(i_fit),output, false);
      // cout << fits_.at(i_fit)->GetFunction("RadialCBOFunc")->GetParameter(0) << endl;
      // FancyDraw(res_.at(i_fit),";Decay time [#mus];Fit residual [mm]","../images/run2C/4parRadialCBOResidual_5100A_"+to_string(i_fit),output);//";Frequency [MHz];Normalised magnitude","../images/RadialCBOResFFT_5100A_"+to_string(i_fit),output);
      // FancyDraw(fft_.at(i_fit),";Frequency [MHz];Normalised magnitude","../images/run2C/4parRadialCBOResFFT_5100A_"+to_string(i_fit),output);

    }


    // Draw graphs of frequency
    int n = time_.size();
    TGraphErrors *omegaGr = new TGraphErrors(n, time_.data(),omega_.data(),ex_.data(),omegaErrors_.data());
//    omegaGr->GetYaxis()->SetMinimum(1.5);/**/
    OmegaShiftFit(omegaGr,time_.at(0),time_.at(n-1));

    omegaGr->GetYaxis()->SetRangeUser(2.0,2.6);
    DrawScat(omegaGr,"Station "+to_string(stn)+";Decay time [#mus];#omega(t) [rad/#mus]","../images/run2C/4par/S"+to_string(stn)+"_omega");


  
  }


  output->Write();
  output->Close();
  input->Close();
  
  // cout << "\nCreated: " << outputName << " " << output << endl;
  return 0;

}
